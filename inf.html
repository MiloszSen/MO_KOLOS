
<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Magisterka Informatyka</title>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background-color: #1c1c1c;
      color: #e0e0e0;
    }
    .quiz-container {
      width: 90%;
      max-width: 600px;
      background-color: #2c2c2c;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
      text-align: center;
    }
    h1 {
      font-size: 28px;
      margin-bottom: 20px;
      color: #4db8ff;
    }
    .question {
      font-size: 20px;
      margin-bottom: 15px;
    }
    /* NOWE: obrazek pytania */
    #question-image {
      max-width: 100%;
      max-height: 250px;
      margin-bottom: 20px;
      margin: auto;
      border-radius: 8px;
      display: none; /* domyślnie ukryty */
    }
    .options button {
      width: 80%;
      margin: 8px 0;
      padding: 12px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background-color: #3c3c3c;
      color: #e0e0e0;
      transition: background-color 0.3s, transform 0.2s;
    }
    .options button:hover {
      background-color: #5c5c5c;
      transform: scale(1.02);
    }
    .options button.selected {
      background-color: #4db8ff;
      color: #fff;
    }
    .result {
      font-size: 24px;
      margin-top: 20px;
      color: #4db8ff;
    }
    .mistakes {
      max-height: 400px;
      overflow-y: auto;
      font-size: 18px;
      margin-top: 20px;
      color: #e74c3c;
      text-align: left;
      padding-right: 20px;
    }
    .mistakes::-webkit-scrollbar {
      width: 12px;
    }
    .mistakes::-webkit-scrollbar-track {
      background: #3c3c3c;
      border-radius: 10px;
    }
    .mistakes::-webkit-scrollbar-thumb {
      background: #4db8ff;
      border-radius: 10px;
    }
    .mistakes::-webkit-scrollbar-thumb:hover {
      background: #3498db;
    }
    .menu-button {
      margin-top: 30px;
      padding: 12px 24px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background-color: #4db8ff;
      color: #fff;
      transition: background-color 0.3s, transform 0.2s;
    }
    .menu-button:hover {
      background-color: #3498db;
      transform: scale(1.1);
    }
  </style>
</head>
<body>

<div class="quiz-container">
  <h1>Informatyka Magisterka</h1>
  <div id="question-container">
    <div class="question" id="question">Pytanie pojawi się tutaj</div>

    <!-- NOWE: miejsce na obrazek pytania -->
    <img id="question-image" src="" alt="Ilustracja do pytania">

    <div class="options">
      <button onclick="selectAnswer(0)">Odpowiedź 1</button>
      <button onclick="selectAnswer(1)">Odpowiedź 2</button>
      <button onclick="selectAnswer(2)">Odpowiedź 3</button>
      <button onclick="selectAnswer(3)">Odpowiedź 4</button>
    </div>
    <button class="menu-button" id="submit-button" onclick="checkAnswer()">Zatwierdź</button>
  </div>
  <div id="result" class="result"></div>
  <div id="mistakes" class="mistakes"></div>
  <button class="menu-button" onclick="returnToMenu()">Wróć do menu</button>
</div>

<script>
/*
  STRUKTURA PYTANIA Z OBSŁUGĄ OBRAZKA:
  - pole "image" jest opcjonalne
  - jeśli go nie będzie -> obrazek się nie pojawi
  - jeśli będzie (np. "img/plume.png") -> zostanie wyświetlony nad odpowiedziami
*/

const questions = [
  {
    "question": "1. Podaj wartość liczby 126 w zapisie binarnym:",
    "options": [
      "A. 1111111",
      "B. 1111110",
      "C. 1111101",
      "D. 1111000"
    ],
    "answer": [
      "B. 1111110"
    ]
  },
  {
    "question": "2. Jaki jest główny cel użycia funkcji wirtualnych w C++?",
    "options": [
      "A. Przyspieszenie działania programu",
      "B. Zmniejszenie zużycia pamięci przez obiekt",
      "C. Polimorfizm - użycie funkcji nadpisanej przez dowolną z klas pochodnych (wiązanie dynamiczne)",
      "D. Ukrycie implementacji metod przed użytkownikiem"
    ],
    "answer": [
      "C. Polimorfizm - użycie funkcji nadpisanej przez dowolną z klas pochodnych (wiązanie dynamiczne)"
    ]
  },
  {
    "question": "3. Co wypisuje następująca funkcja w C++? (void afunction (int *x) { x=new int; *x=12;} int main() { int v=10; afunction(&v); cout <<v;})",
    "options": [
      "A. Wyjście to 12",
      "B. Wyjście to 10",
      "C. Na wyjściu to adres v",
      "D. Na wyjściu to referencja do v"
    ],
    "answer": [
      "B. Wyjście to 10"
    ]
  },
  {
    "question": "4. Jaka jest długość łańcucha znaków \"1\\t2\\t2\" w C++?",
    "options": [
      "A. 3",
      "B. 5",
      "C. 7",
      "D. 9"
    ],
    "answer": [
      "B. 5"
    ]
  },
  {
    "question": "5. Mając podany fragment kodu programu w C++, podać, co zostanie wypisane na ekranie? (int Count1 = 1; int Count2 = 2; if (Count1 != Count2) ++Count2; else ++Count1; ++Count2; cout << Count1 << '\\t' << Count2;)",
    "options": [
      "A. 1 4",
      "B. 2 2",
      "C. 1 3",
      "D. 2 3"
    ],
    "answer": [
      "A. 1 4"
    ]
  },
  {
    "question": "6. Która z podanych poniżej jest poprawną deklaracją klasy w C++?",
    "options": [
      "A. class A { int x; };",
      "B. class B {}",
      "C. public class A {}",
      "D. object A {int x;};"
    ],
    "answer": [
      "A. class A { int x; };"
    ]
  },
  {
    "question": "7. Co wypisze następujący fragment kodu programu w C++? (void f(int a, int &b) { int t; t = b; a = b; } ... x=4, y=5; f(x, y);)",
    "options": [
      "A. x is 5 y is 5",
      "B. x is 4 y is 4",
      "C. x is 4 y is 5",
      "D. x is 5 y is 4"
    ],
    "answer": [
      "C. x is 4 y is 5"
    ]
  },
  {
    "question": "8. Ile razy wyświetli się na ekranie napis 2010, w wyniku działania kodu dla danych: 1 2 <Enter> 3 <Enter> <Ctrl-Z> <Enter>?",
    "options": [
      "A. 0",
      "B. 1",
      "C. 2",
      "D. 3"
    ],
    "answer": [
      "D. 3"
    ]
  },
  {
    "question": "9. Czy wyrażenie o postaci ('ab'==\"ab\") jest prawdziwe w C++?",
    "options": [
      "A. nie, znak ASCII nie są sobie równe",
      "B. nie, chyba że == zastąpimy =",
      "C. tak",
      "D. nie, nie skompiluje się"
    ],
    "answer": [
      "D. nie, nie skompiluje się"
    ]
  },
  {
    "question": "10. Co wypisze następujący program w C++?",
    "options": [
      "A. -9",
      "B. -7",
      "C. -6",
      "D. -8"
    ],
    "answer": [
      "D. -8"
    ],
    image: "img/inf10.png" 
  },
  {
    "question": "11. Powtórzenie wykonania jakiegoś kodu można uzyskać w wyniku użycia instrukcji:",
    "options": [
      "A. użycia instrukcji while",
      "B. użycia instrukcji for",
      "C. użycia funkcji rekurencyjnej",
      "D. użycia instrukcji if"
    ],
    "answer": [
      "A. użycia instrukcji while",
      "B. użycia instrukcji for",
      "C. użycia funkcji rekurencyjnej"
    ]
  },
  {
    "question": "12. Niech lista będzie nazwą listy. Zapis w języku Python: lista[1:] spowoduje...",
    "options": [
      "A. pozwala na uzyskanie ogona listy",
      "B. jest błędny",
      "C. spowoduje powstanie listy składającej się ze wszystkich elementów listy oprócz pierwszego",
      "D. Oznacza, że lista jest listą krotek"
    ],
    "answer": [
      "A. pozwala na uzyskanie ogona listy",
      "C. spowoduje powstanie listy składającej się ze wszystkich elementów listy oprócz pierwszego"
    ]
  },
  {
    "question": "13. Dana jest funkcja iter(n). Jej odpowiednik rekurencyjny to rek(n, __kod1__). Gdzie wpisy powinny być następujące:",
    "options": [
      "A. __kod4__ to while",
      "B. __kod2__ to n * acc",
      "C. __kod3__ to n * acc",
      "D. __kod1__ to acc=1"
    ],
    "answer": [
      "C. __kod3__ to n * acc",
      "D. __kod1__ to acc=1"
    ]
  },
  {
    "question": "14. Dana jest funkcja w Pythonie: def fun(par1, par2 = 0.0): return par1 + par2. Co spowodują wywołania?",
    "options": [
      "A. wywołanie fun( 3 ) spowoduje błąd",
      "B. wywołanie fun( 'a' ) spowoduje błąd",
      "C. wywołanie fun( 3 ) zwróci wartość rzeczywistą",
      "D. wywołanie fun( 'a', 'b' ) spowoduje błąd"
    ],
    "answer": [
      "B. wywołanie fun( 'a' ) spowoduje błąd",
      "C. wywołanie fun( 3 ) zwróci wartość rzeczywistą"
    ]
  },
  {
    "question": "15. Zapis w języku C: void funkcja( int ** par); deklaruje funkcję, która jako argument może otrzymać:",
    "options": [
      "A. Dynamicznie utworzoną dwuwymiarową tablicę liczb całkowitych",
      "B. Adres dynamicznie tworzonej tablicy liczb całkowitych",
      "C. Tablicę wskaźników do liczb całkowitych",
      "D. Adres adresu liczby całkowitej"
    ],
    "answer": [
      "A. Dynamicznie utworzoną dwuwymiarową tablicę liczb całkowitych",
      "C. Tablicę wskaźników do liczb całkowitych",
      "D. Adres adresu liczby całkowitej"
    ]
  },
  {
    "question": "16. Co spowoduje wywołanie w języku C kodu: float *x = malloc(10 * sizeof *x); float a = *x; float b = x[0];",
    "options": [
      "A. gwarantuje, że wartość zmiennej a wyniesie 0",
      "B. jest niepoprawny (zgłoszony będzie błąd w trakcie kompilacji)",
      "C. w linii 1 stworzy tablicę 10 elementową liczb rzeczywistych",
      "D. spowoduje, że zmienne a i b będą miały identyczną wartość"
    ],
    "answer": [
      "C. w linii 1 stworzy tablicę 10 elementową liczb rzeczywistych",
      "D. spowoduje, że zmienne a i b będą miały identyczną wartość"
    ]
  },
  {
    "question": "17. Zaznacz prawidłowe odpowiedzi dotyczące kodu (funkcja zwracająca &x lokalne):",
    "options": [
      "A. w linii z instrukcją return powinien wystąpić zapis *x zamiast &x",
      "B. występuje zapis, który może spowodować błędne obliczenia w przypadku użycia tej funkcji",
      "C. występuje funkcja zwracająca adres wartości całkowitej",
      "D. występuje pobranie adresu zmiennej znajdującej się na stosie"
    ],
    "answer": [
      "B. występuje zapis, który może spowodować błędne obliczenia w przypadku użycia tej funkcji",
      "C. występuje funkcja zwracająca adres wartości całkowitej",
      "D. występuje pobranie adresu zmiennej znajdującej się na stosie"
    ]
  },
  {
    "question": "18. Jaki będzie rezultat próby zbudowania i uruchomienia poniższego kodu? (redefinicja 'i' w pętli for)",
    "options": [
      "A. Definicja zmiennej 'i' w pętli zostanie zignorowana",
      "B. Zostaną zgłoszone błędy składniowe",
      "C. Próba redefinicji zmiennej 'i' spowoduje błąd kompilacji",
      "D. Zmienna 'i' zdefiniowana w pętli przesłoni zmienną 'i' z początku funkcji - wypisane zostaną 0, 1 i 2"
    ],
    "answer": [
      "D. Zmienna 'i' zdefiniowana w pętli przesłoni zmienną 'i' z początku funkcji - wypisane zostaną 0, 1 i 2"
    ]
  },
  {
    "question": "19. Jaką wartością jest domyślnie inicjalizowana zmienna automatyczna w języku C?",
    "options": [
      "A. Wartością 0 dla typów numerycznych",
      "B. Domyślna wartość zależy od typu zmiennej, nie ma żadnej ogólnej zasady",
      "C. Zmienna automatyczna nie jest domyślnie inicjalizowana",
      "D. Zmienna automatyczna jest domyślnie inicjalizowana „null”"
    ],
    "answer": [
      "B. Domyślna wartość zależy od typu zmiennej, nie ma żadnej ogólnej zasady"
    ]
  },
  {
    "question": "20. Wskaż poprawne odpowiedzi dotyczące tzw. strażnika nagłówka (ang. header guard):",
    "options": [
      "A. Jego poprawna konstrukcja to #ifndef UNIKALNE_ID / #define UNIKALNE_ID / #endif",
      "B. Zabezpiecza przed kilkukrotnym dołączeniem elementów tego samego pliku nagłówkowego",
      "C. Konstrukcja #define UNIKALNE_ID / #endif jest wystarczająca",
      "D. Powinien obejmować całą zawartość danego pliku nagłówkowego"
    ],
    "answer": [
      "A. Jego poprawna konstrukcja to #ifndef UNIKALNE_ID / #define UNIKALNE_ID / #endif",
      "B. Zabezpiecza przed kilkukrotnym dołączeniem elementów tego samego pliku nagłówkowego",
      "D. Powinien obejmować całą zawartość danego pliku nagłówkowego"
    ]
  },
  {
    "question": "21. Stała metoda (ang. const member function)...",
    "options": [
      "A. Oznacza, że dana metoda nie modyfikuje stanu obiektu, dla którego została wywołana",
      "B. Oznacza, że dana metoda zwraca wartość typu const",
      "C. Jest oznaczana poprzez dodanie kwalifikatora „const” po liście parametrów metody",
      "D. Jest oznaczana poprzez dodanie kwalifikatora „const” przed listą parametrów metody"
    ],
    "answer": [
      "A. Oznacza, że dana metoda nie modyfikuje stanu obiektu, dla którego została wywołana",
      "C. Jest oznaczana poprzez dodanie kwalifikatora „const” po liście parametrów metody"
    ]
  },
  {
    "question": "22. Wybierz poprawną odpowiedź dotyczącą operacji na wskaźniku zadeklarowanym jako const T* p (T – dowolny typ podstawowy):",
    "options": [
      "A. Nie można zmienić stanu wskazywanego obiektu, natomiast można przepiąć wskaźnik na inny obiekt",
      "B. Nie można zmienić stanu wskazywanego obiektu oraz nie można przepiąć wskaźnika na inny obiekt",
      "C. Można zmienić stan wskazywanego obiektu, natomiast nie można przepiąć wskaźnika na inny obiekt",
      "D. Można zarówno zmienić stan wskazywanego obiektu, jak i przepiąć wskaźnik na inny obiekt"
    ],
    "answer": [
      "A. Nie można zmienić stanu wskazywanego obiektu, natomiast można przepiąć wskaźnik na inny obiekt"
    ]
  },
  {
    "question": "23. Która pętla pozwoli poprawnie wypisać kolejno wszystkie elementy obiektu `std::vector v = {1, 2, 3}`?",
    "options": [
      "A. for (auto& el : v) { std::cout << el << std::endl; }",
      "B. for (auto it = v.begin(); it <= v.end(); ++it) { std::cout << *it; }",
      "C. for (auto it = v.begin(); it < v.end(); ++it) { std::cout << *it; }",
      "D. for (auto& el : v) { std::cout << *el << std::endl; }"
    ],
    "answer": [
      "A. for (auto& el : v) { std::cout << el << std::endl; }",
      "C. for (auto it = v.begin(); it < v.end(); ++it) { std::cout << *it; }"
    ]
  },
  {
    "question": "24. Wybierz stwierdzenia odnoszące się do metody czysto wirtualnej:",
    "options": [
      "A. Metoda czysto wirtualna nie musi zostać zdefiniowana w klasie, w której została zadeklarowana",
      "B. Aby zaznaczyć, że dana metoda jest w pełni wirtualna, dodajemy na końcu jej deklaracji „=0”",
      "C. Dodanie do klasy metody czysto wirtualnej powoduje, że klasa ta staje się klasą abstrakcyjną",
      "D. Metoda czysto wirtualna musi zostać zdefiniowana w klasie, w której została zadeklarowana"
    ],
    "answer": [
      "A. Metoda czysto wirtualna nie musi zostać zdefiniowana w klasie, w której została zadeklarowana",
      "B. Aby zaznaczyć, że dana metoda jest w pełni wirtualna, dodajemy na końcu jej deklaracji „=0”",
      "C. Dodanie do klasy metody czysto wirtualnej powoduje, że klasa ta staje się klasą abstrakcyjną"
    ]
  },
  {
    "question": "25. Wybierz prawdziwe stwierdzenia odnoszące się do sytuacji, gdy klasa posiada pole będące wskaźnikiem std::unique_ptr:",
    "options": [
      "A. Dla takiej klasy nie zostanie wygenerowany konstruktor domyślny",
      "B. Dla takiej klasy nie zostanie wygenerowany domyślny konstruktor kopiujący",
      "C. Dla takiej klasy nie zostanie wygenerowany domyślny operator przypisania",
      "D. Nie można stworzyć obiektu takiej klasy"
    ],
    "answer": [
      "B. Dla takiej klasy nie zostanie wygenerowany domyślny konstruktor kopiujący",
      "C. Dla takiej klasy nie zostanie wygenerowany domyślny operator przypisania"
    ]
  },
  {
    "question": "26. Które stwierdzenia są prawdziwe w odniesieniu do destruktora klasy?",
    "options": [
      "A. Wywoływany jest automatycznie w momencie, kiedy kończy się cykl życia obiektu",
      "B. Odpowiada za zwolnienie zasobów przydzielonych obiektowi",
      "C. Należy go wywołać jawnie w momencie, kiedy kończy się cykl życia obiektu",
      "D. Każda klasa posiada destruktor domyślny"
    ],
    "answer": [
      "A. Wywoływany jest automatycznie w momencie, kiedy kończy się cykl życia obiektu",
      "B. Odpowiada za zwolnienie zasobów przydzielonych obiektowi",
      "D. Każda klasa posiada destruktor domyślny"
    ]
  },
  {
    "question": "27. Które stwierdzenia są prawdziwe w odniesieniu do konstruktora klasy?",
    "options": [
      "A. Każda klasa zawsze posiada konstruktor domyślny",
      "B. Konstruktor zwraca wartość logiczną informującą o tym, czy udało się poprawnie utworzyć obiekt",
      "C. Klasa może definiować dowolną liczbę konstruktorów, o ile różnią się one między sobą liczbą lub typem parametrów",
      "D. Nazwa konstruktora jest identyczna z nazwą klasy"
    ],
    "answer": [
      "C. Klasa może definiować dowolną liczbę konstruktorów, o ile różnią się one między sobą liczbą lub typem parametrów",
      "D. Nazwa konstruktora jest identyczna z nazwą klasy"
    ]
  }
];

let shuffledQuestions = [];
let currentQuestionIndex = 0;
let selectedAnswers = [];
let score = 0;
let mistakes = [];
let currentOptions = [];

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function startQuiz() {
  shuffledQuestions = [...questions];
  shuffle(shuffledQuestions);
  currentQuestionIndex = 0;
  score = 0;
  mistakes = [];
  loadQuestion();
}

function loadQuestion() {
  document.getElementById("question-container").style.display = "block";
  document.getElementById("result").innerHTML = "";
  document.getElementById("mistakes").innerHTML = "";

  const questionData = shuffledQuestions[currentQuestionIndex];
  document.getElementById("question").innerText = questionData.question;

  // NOWE: obsługa obrazka
  const imgEl = document.getElementById("question-image");
  if (questionData.image && questionData.image.trim() !== "") {
    imgEl.src = questionData.image;
    imgEl.style.display = "block";
  } else {
    imgEl.src = "";
    imgEl.style.display = "none";
  }

  currentOptions = questionData.options.map(opt => ({
    text: opt,
    correct: questionData.answer.includes(opt)
  }));

  shuffle(currentOptions);
  selectedAnswers = [];

  const buttons = document.querySelectorAll(".options button");
  currentOptions.forEach((optionObj, index) => {
    const button = buttons[index];
    button.innerText = optionObj.text;
    button.classList.remove("selected");
    button.disabled = false;
  });
}

function selectAnswer(index) {
  const button = document.querySelectorAll(".options button")[index];
  if (button.classList.contains("selected")) {
    button.classList.remove("selected");
    selectedAnswers = selectedAnswers.filter(i => i !== index);
  } else {
    button.classList.add("selected");
    selectedAnswers.push(index);
  }
}

function checkAnswer() {
  const correctIndexes = currentOptions
    .map((obj, i) => obj.correct ? i : -1)
    .filter(i => i >= 0);

  if (JSON.stringify(selectedAnswers.sort()) === JSON.stringify(correctIndexes.sort())) {
    score++;
  } else {
    const questionData = shuffledQuestions[currentQuestionIndex];
    mistakes.push({
      question: questionData.question,
      selectedAnswer: selectedAnswers.map(idx => currentOptions[idx].text),
      correctAnswer: correctIndexes.map(idx => currentOptions[idx].text)
    });
  }

  currentQuestionIndex++;
  if (currentQuestionIndex < shuffledQuestions.length) {
    loadQuestion();
  } else {
    showResult();
  }
}

function showResult() {
  document.getElementById("question-container").style.display = "none";
  document.getElementById("result").innerText = `Twój wynik: ${score} / ${shuffledQuestions.length}`;

  if (mistakes.length > 0) {
    let mistakeText = "Błędne odpowiedzi:<br>";
    mistakes.forEach((mistake, index) => {
      mistakeText += `${index + 1}. ${mistake.question}<br>
                      Twoje odpowiedzi: ${mistake.selectedAnswer.join(", ")}<br>
                      Poprawne odpowiedzi: ${mistake.correctAnswer.join(", ")}<br><br>`;
    });
    document.getElementById("mistakes").innerHTML = mistakeText;
  } else {
    document.getElementById("mistakes").innerText = "Gratulacje! Wszystkie odpowiedzi były poprawne.";
  }
}

function returnToMenu() {
  window.location.href = "index.html";
}

startQuiz();
</script>

</body>
</html>


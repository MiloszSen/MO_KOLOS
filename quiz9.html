<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZAMKNIETE MO</title>
    <style>
        /* Nowoczesny styl dla quizu */
        body {
            font-family: 'Roboto', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #1c1c1c;
            color: #e0e0e0;
        }
        .quiz-container {
            width: 90%;
            max-width: 600px;
            background-color: #2c2c2c;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #4db8ff ;
        }
        .question {
            font-size: 20px;
            margin-bottom: 20px;
        }
        .options button {
            width: 80%;
            margin: 8px 0;
            padding: 12px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            background-color: #3c3c3c;
            color: #e0e0e0;
            transition: background-color 0.3s, transform 0.2s;
        }
        .options button:hover {
            background-color: #5c5c5c;
            transform: scale(1.02);
        }
        .options button.selected {
            background-color: #4db8ff;
            color: #fff;
        }
        .result {
            font-size: 24px;
            margin-top: 20px;
            color: #4db8ff;
        }
        .mistakes {
            max-height: 400px; 
            overflow-y: auto;
            font-size: 18px;
            margin-top: 20px;
            color: #e74c3c;
            text-align: left;
            padding-right: 20px;
        }
        .mistakes::-webkit-scrollbar {
            width: 12px;
        }
        .mistakes::-webkit-scrollbar-track {
            background: #3c3c3c; 
            border-radius: 10px;
        }
        .mistakes::-webkit-scrollbar-thumb {
            background: #4db8ff; 
            border-radius: 10px;
        }
        .mistakes::-webkit-scrollbar-thumb:hover {
            background: #3498db; 
        }
        .menu-button {
            margin-top: 30px;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            background-color: #4db8ff;
            color: #fff;
            transition: background-color 0.3s, transform 0.2s;
        }
        .menu-button:hover {
            background-color: #3498db;
            transform: scale(1.1);
        }
    </style>
</head>
<body>

<div class="quiz-container">
    <h1>ZAMKNIETE MO</h1>
    <div id="question-container">
        <div class="question" id="question">Pytanie pojawi się tutaj</div>
        <div class="options">
            <button onclick="selectAnswer(0)">Odpowiedź 1</button>
            <button onclick="selectAnswer(1)">Odpowiedź 2</button>
            <button onclick="selectAnswer(2)">Odpowiedź 3</button>
            <button onclick="selectAnswer(3)">Odpowiedź 4</button>
        </div>
        <button class="menu-button" id="submit-button" onclick="checkAnswer()">Zatwierdź</button>
    </div>
    <div id="result" class="result"></div>
    <div id="mistakes" class="mistakes"></div>
    <button class="menu-button" onclick="returnToMenu()">Wróć do menu</button>
</div>

<script>
    const questions = [
        {
            "question": "Metody funkcji kary zewnętrznej. Problem optymalizacji sprowadza się do:",
            "options": [
                "dodania funkcji kary do funkcji celu",
                "własności funkcji kary: funkcja kary powinna być ciągła i jeśli jest rozwiązaniem dopuszczalnym wówczas S(x)=0; w przeciwnym razie S(x)>0",
                "punkt startowy musi należeć do zbioru rozwiązań dopuszczalnych",
                "zastąpienia optymalizacji z ograniczeniami optymalizacją bez ograniczeń"
            ],
            "answer": [
                "dodania funkcji kary do funkcji celu",
                "własności funkcji kary: funkcja kary powinna być ciągła i jeśli jest rozwiązaniem dopuszczalnym wówczas S(x)=0; w przeciwnym razie S(x)>0",
                "zastąpienia optymalizacji z ograniczeniami optymalizacją bez ograniczeń"
            ]
        },
        {
        "question": "Metody funkcji kary wewnętrznej. Problem optymalizacji sprowadza się do:",
        "options": [
            "zastąpienia optymalizacji z ograniczeniami optymalizacją bez ograniczeń",
            "punkt startowy musi należeć do zbioru rozwiązań dopuszczalnych",
            "dodaniu funkcji kary do funkcji celu",
            "własności funkcji kary: funkcja kary powinna być ciągła i jeśli jest rozwiązaniem dopuszczalnym wówczas S(x)=0; w przeciwnym razie S(x)>0"
        ],
        "answer": [
            "zastąpienia optymalizacji z ograniczeniami optymalizacją bez ograniczeń",
            "punkt startowy musi należeć do zbioru rozwiązań dopuszczalnych",
            "dodaniu funkcji kary do funkcji celu"
        ]
    },
    {
        "question": "W metodzie największego spadku kolejny punkt x(i+1) przybliżający minimum dany jest wzorem:",
        "options": [
            "x(i+1) = x(i) - h(i) H^(-1)(x(i)) ∇f(x(i))",
            "x(i+1) = x(i) + h(i) ∇f(x(i))",
            "x(i+1) = x(i) + h(i) d(i)",
            "x(i+1) = x(i) - h(i) ∇f(x(i))"
        ],
        "answer": [
            "x(i+1) = x(i) + h(i) d(i)",
            "x(i+1) = x(i) - h(i) ∇f(x(i))"
        ]
    },
    {
        "question": "W metodzie Newtona kolejny punkt x(i+1) przybliżający minimum dany jest wzorem:",
        "options": [
            "x(i+1) = x(i) + h(i) d(i)",
            "x(i+1) = x(i) - h(i) H^(-1)(x(i)) ∇f(x(i))",
            "x(i+1) = x(i) - h(i) ∇f(x(i))",
            "x(i+1) = x(i) + h(i) H^(-1)(x(i)) ∇f(x(i))"
        ],
        "answer": [
            "x(i+1) = x(i) + h(i) d(i)",
            "x(i+1) = x(i) - h(i) H^(-1)(x(i)) ∇f(x(i))"
        ]
    },
        {
            "question": "Wynikiem poszukiwań metodą ekspansji dla spełnionego warunku końcowego stopu jest:",
            "options": [
                "Punkt x(i)",
                "Przedział [x(i-1), x(i+1)] zawierający wartość minimalną.",
                "Przedział [x(i), x(i+1)] zawierający wartość minimalną.",
                "Przedział [x(i-1), x(i)] zawierający wartość minimalną."
            ],
            "answer": "Przedział [x(i-1), x(i+1)] zawierający wartość minimalną."
        },
        {
            "question": "Dla spełnionego warunku f(x') ≥ f(x(i+1)) metoda ekspansji:",
            "options": [
                "Zwraca wynik, przedział [x(i), x(i+1)].",
                "Zwraca wynik, przedział [x(i-1), x(i+1)] zawierający minimum funkcji celu.",
                "Zwraca wynik, przedział [x(i-1), x(i)] zawierający minimum funkcji celu.",
                "Rozszerza przedział poszukiwań."
            ],
            "answer": "Rozszerza przedział poszukiwań."
        },
        {
            "question": "Jeśli zachodzi warunek f(x(1))=f(x(0)) dla spełnionych założeń metody ekspansji to:",
            "options": [
                "Minimum występuje w przedziale [x(0), x(1)].",
                "Funkcja nie jest unimodalna.",
                "Maximum występuje w przedziale [x(0), x(1)].",
                "Nie można wnioskować, że minimum występuje w przedziale [x(0), x(1)]."
            ],
            "answer": "Minimum występuje w przedziale [x(0), x(1)]."
        },
        {
            "question": "Warunkiem koniecznym wyznaczenia przedziału zawierającego minimum globalne w metodzie ekspansji jest:",
            "options": [
                "Unimodalność funkcji celu.",
                "n-krotna różniczkowalność funkcji celu.",
                "Różniczkowalność funkcji celu.",
                "Ograniczoność przedziału poszukiwań."
            ],
            "answer": "Unimodalność funkcji celu."
        },
        {
            "question": "Jeżeli w i-tej iteracji zachodzi zależność a(i) < c(i) < d(i) oraz f(c(i)) < f(d(i)), to w kolejnej iteracji:",
            "options": [
                "Zmienia się ograniczenie lewostronne.",
                "Spełniony jest warunek stopu.",
                "Zmienia się ograniczenie prawostronne.",
                "Funkcja nie jest unimodalna."
            ],
            "answer": "Zmienia się ograniczenie prawostronne."
        },
        {
            "question": "Wynikiem optymalizacji metodą złotego podziału jest:",
            "options": [
                "a(i)",
                "b(i)",
                "(b(i)-a(i))/2",
                "|b(i)-a(i)|"
            ],
            "answer": "(b(i)-a(i))/2"
        },
        {
            "question": "Jeżeli w i-tej iteracji zachodzi zależność a(i) < d(i) < c(i) oraz f(d(i)) < f(c(i)), to w kolejnej iteracji:",
            "options": [
                "Zmienia się ograniczenie prawostronne.",
                "Funkcja osiąga minimum.",
                "Zmienia się ograniczenie lewostronne.",
                "Spełniony jest warunek stopu."
            ],
            "answer": "Zmienia się ograniczenie prawostronne."
        },
        {
            "question": "Wynikiem optymalizacji metodą Lagrange'a dla b(i)-a(i)<ε jest:",
            "options": [
                "b(i)",
                "a(i)",
                "d(i)",
                "(b(i)-a(i))/2"
            ],
            "answer": "d(i)"
        },
        {
            "question": "Jeżeli etap próbny nie przynosi poprawy wartości funkcji celu w stosunku do wartości w punkcie startowym dla s > ε to:",
            "options": [
                "Kolejnym krokiem jest wykonanie etapu roboczego.",
                "Należy zmienić krok poszukiwań s=αs.",
                "Spełniony jest warunek stopu.",
                "Należy zmienić bazę."
            ],
            "answer": "Należy zmienić krok poszukiwań s=αs."
        },
        {
            "question": "Wynik optymalizacji metodą Hooke'a-Jeevesa dla s < ε to:",
            "options": [
                "Współrzędne ostatniej bazy.",
                "x ← x + se(j).",
                "||x||",
                "x = 2x(B) - x̄(B)"
            ],
            "answer": "Współrzędne ostatniej bazy."
        }
    ];

    let shuffledQuestions = [];
    let currentQuestionIndex = 0;
    let selectedAnswers = [];
    let score = 0;
    let mistakes = [];

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function startQuiz() {
        shuffledQuestions = [...questions];
        shuffle(shuffledQuestions);
        currentQuestionIndex = 0;
        score = 0;
        mistakes = [];
        loadQuestion();
    }

    function loadQuestion() {
        document.getElementById("question-container").style.display = "block";
        document.getElementById("result").innerHTML = "";
        document.getElementById("mistakes").innerHTML = "";

        const questionData = shuffledQuestions[currentQuestionIndex];
        document.getElementById("question").innerText = questionData.question;

        // Czyszczenie zaznaczeń
        selectedAnswers = [];

        const options = document.querySelectorAll(".options button");
        options.forEach((button, index) => {
            button.innerText = questionData.options[index];
            button.classList.remove("selected");
            button.disabled = false;
        });
    }

    function selectAnswer(index) {
        const button = document.querySelectorAll(".options button")[index];

        // Toggle zaznaczenia
        if (button.classList.contains("selected")) {
            button.classList.remove("selected");
            selectedAnswers = selectedAnswers.filter(i => i !== index);
        } else {
            button.classList.add("selected");
            selectedAnswers.push(index);
        }
    }

    function checkAnswer() {
        const questionData = shuffledQuestions[currentQuestionIndex];
        
        // Wyznaczamy indeksy poprawnych odpowiedzi
        const correctAnswers = Array.isArray(questionData.answer)
            ? questionData.answer.map(ans => questionData.options.indexOf(ans))
            : [questionData.options.indexOf(questionData.answer)];

        // Sprawdzamy zgodność tablic (porównanie sortowanych)
        if (JSON.stringify(selectedAnswers.sort()) === JSON.stringify(correctAnswers.sort())) {
            score++;
        } else {
            mistakes.push({
                question: questionData.question,
                selectedAnswer: selectedAnswers.map(index => questionData.options[index]),
                correctAnswer: Array.isArray(questionData.answer)
                    ? questionData.answer
                    : [questionData.answer]
            });
        }

        currentQuestionIndex++;
        if (currentQuestionIndex < shuffledQuestions.length) {
            loadQuestion();
        } else {
            showResult();
        }
    }

    function showResult() {
        document.getElementById("question-container").style.display = "none";
        document.getElementById("result").innerText =
            `Twój wynik: ${score} / ${shuffledQuestions.length}`;

        if (mistakes.length > 0) {
            let mistakeText = "Błędne odpowiedzi:<br>";
            mistakes.forEach((mistake, index) => {
                mistakeText += `${index + 1}. ${mistake.question}<br>
                                Twoje odpowiedzi: ${mistake.selectedAnswer.join(<br>)}<br>
                                Poprawne odpowiedzi: ${mistake.correctAnswer.join(<br>)}<br><br>`;
            });
            document.getElementById("mistakes").innerHTML = mistakeText;
        } else {
            document.getElementById("mistakes").innerText =
                "Gratulacje! Wszystkie odpowiedzi były poprawne.";
        }
    }

    function returnToMenu() {
        // Zmień na właściwą ścieżkę do menu
        window.location.href = "index.html";
    }

    // Start automatycznie przy wczytaniu
    startQuiz();
</script>

</body>
</html>
